# ğŸ“ 477. Total Hamming Distance
2025-01-30

11:22

# ğŸ·ï¸ Tags

[[Arrays]]
[[Math]]
[[BitWise Operations]]

## ğŸ“„ Problem Description
<!-- Briefly describe the problem statement here -->
TheÂ [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance)Â between two integers is the number of positions at which the corresponding bits are different.

Given an integer arrayÂ `nums`, returnÂ _the sum ofÂ **Hamming distances**Â between all the pairs of the integers in_Â `nums`.

## ğŸ§  Algorithm Used
<!-- Describe the algorithm you used to solve the problem -->
### **I tried the nested loop approach.**
For a pair, to find the hamming distance is quite easy. You simply - 
	- XOR the numbers
	- Put it in a variable
	- count the number of 1s in the variable.

Then, I has 2 loops, inner and outer where I called the hamming distance function for each pair of numbers.
IT WORKED.
IT WAS ALSO A BIT SHITE TO BE HONEST, O(n^2) [eww]. 

The OPTIMIZED algo is as follows. 
- for each position, calculate how many numbers have a 1.
- for each bit position, the contribution to the total hamming distance is the product of the number of 1s and the number of 0s.

## ğŸ› ï¸ Approach
<!-- Explain your approach step-by-step -->

1. Loop through each bit position
2. Count the number of 1s at the current bit position
3. Calculate the contribution to the total Hamming distance

## ğŸ’» Accepted Code

```

int totalHammingDistance(int* nums, int numsSize) {
Â  Â  int totalHD = 0;
Â  Â  for (int i = 0; i < 32; i++) {
Â  Â  Â  Â  int bitCount = 0;
Â  Â  Â  Â  for (int j = 0; j < numsSize; j++) {
Â  Â  Â  Â  Â  Â  bitCount += (nums[j] >> i) & 1;
Â  Â  Â  Â  }
Â  Â  Â  Â  totalHD += bitCount * (numsSize - bitCount);
Â  Â  }
Â  Â  return totalHD;
}

```

# ğŸ“Š Complexity Analysis
Time Complexity:
Space Complexity:


### ğŸ”— Reference
[Total Hamming Distance - LeetCode](https://leetcode.com/problems/total-hamming-distance/)
### ğŸ“ Notes
