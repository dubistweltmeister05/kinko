# ğŸ“ 50. Pow(x,n)
2025-02-02

09:03

# ğŸ·ï¸ Tags
[[Recursion]]
[[Math]]

## ğŸ“„ Problem Description
<!-- Briefly describe the problem statement here -->
ImplementÂ [pow(x, n)](http://www.cplusplus.com/reference/valarray/pow/), which calculatesÂ `x`Â raised to the powerÂ `n`Â (i.e.,Â `x^n`).
## ğŸ§  Algorithm Used
<!-- Describe the algorithm you used to solve the problem -->
1. **Base Case**:
    - IfÂ n=0n=0, returnÂ 11Â because any number raised to the power of 0 is 1.
        
2. **Handle Negative Exponents**:
    - IfÂ nnÂ is negative, convert the problem to computingÂ 1xâˆ’nx1â€‹âˆ’n. This is done by settingÂ x=1xx=x1â€‹Â and makingÂ nnÂ positive.
        
3. **Recursive Case**: 
    - IfÂ nnÂ is even, computeÂ xnxnÂ asÂ (x2)n/2(x2)n/2. This is done by squaringÂ xxÂ and halvingÂ nn.
        
    - IfÂ nnÂ is odd, computeÂ xnxnÂ asÂ xâ‹…(x2)(nâˆ’1)/2xâ‹…(x2)(nâˆ’1)/2. This is done by multiplyingÂ xxÂ with the result ofÂ (x2)(nâˆ’1)/2(x2)(nâˆ’1)/2.
4. **Recursion**:
    - The function calls itself recursively with the updatedÂ xxÂ andÂ nnÂ untilÂ nnÂ becomes 0.
## ğŸ› ï¸ Approach
<!-- Explain your approach step-by-step -->

5. 
6. 
7. 

## ğŸ’» Accepted Code
```
double myPow(double x, int n) {
    if (n == 0) {
        return 1;
    }

    long long N = n; 
    if (N < 0) {
        x = 1 / x;
        N = -N; 
    }

    if (N % 2 == 0) {
        return myPow(x * x, N / 2);
    } else {
        return x * myPow(x * x, N / 2);
    }
}

```
# ğŸ“Š Complexity Analysis
Time Complexity:
Space Complexity:


### ğŸ”— Reference
[Pow(x, n) - LeetCode](https://leetcode.com/problems/powx-n/)

### ğŸ“ Notes
